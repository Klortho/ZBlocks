<!--
  Testing out the transformation matrix library 
  (https://github.com/epistemex/transformation-matrix-js) in the console.
-->
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Jig - Matrix</title>
    <style type="text/css">
      canvas { border: 1px solid #DDD; }
    </style>
    <script src='../node_modules/transformation-matrix-js/matrix.js'></script>
  </head>
  <body>
    <p>
      The script on this page manages its own transformation matrix chain, and
      each time you click on the box, it computes the next matrix, and overrides
      anything set by the canvas.
    </p>
    <canvas id="canvas" width="600" height="300"></canvas>

    <script>
      // get some data from the environment
      const canvas = document.getElementById('canvas');
      const width = canvas.width;
      const height = canvas.height;

      // ----- good up to here ------

      // graphical context of the canvas
      const ctx = canvas.getContext('2d');


      // This is our centalized object that keeps the mutable master matrix.
      // Whenever the matrix changes, this sets ctx as well.
      // "mm" == matrix man.
      const mm = {
        // The default baseline root matrix, that can't be overridden
        root: (new Matrix()).translate(width/2, height/2),

        // Current matrix - this is initialize right away with root
        current: null,

        // reset to root
        reset: () => mm.set(mm.root),

        set: function(m) {
          console.log('setting transform to ', m);
          mm.current = m;
          m.applyToContext(ctx);
        },

        // Apply a new transformation on top of the old one
        multiply: function(m) {
          console.log('multiplying matrix ', m);
          mm.set(mm.current.clone().multiply(m));
        },
      };
      mm.reset();


      // utility function - get a random new color
      const randomColor = function() {
        // split a sum color value of 200 at random
        const bases = [1, 2, 3].map(Math.random);
        const sum = bases[0] + bases[1] + bases[2];
        const rgb = bases.map(b => Math.floor(200 * b / sum));
        const rgba = rgb.concat(0.2);
        const str = 'rgba(' + rgba.join(', ') + ')'; 
        console.log('random color: ', str);
        return str;
      };

      // This draws a fixed size-position box (in whatever matrix it is embedded
      // within) with a random color
      const box = function() {
        console.log('drawing a box');
        ctx.fillStyle = randomColor();
        ctx.fillRect (-50, -30, 100, 60);
      };

      // test set of transform matrices
      var transforms = [
        (new Matrix()),
        (new Matrix()).scale(2, 2),
        (new Matrix()).rotateDeg(45),
        (new Matrix()).rotateDeg(45),
        (new Matrix()).rotateDeg(45),
        (new Matrix()).shearX(2),
      ];

      // This cycles through the set, multiplying the next matrix on top of
      // the current.
      var next = 0;
      const renderNext = function() {
        console.log('rendering next');
        mm.multiply(transforms[next]);
        box();
        next = (next + 1) % 6;
      };

      canvas.onclick = renderNext;

    </script>
  </body>
</html>